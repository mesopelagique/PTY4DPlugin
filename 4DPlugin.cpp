//4DPlugin.cpp
/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : 4d-plugin-pty
 #	author : Eric
 #	2/14/26
 #
 # --------------------------------------------------------------------------------*/

#include "4DPluginAPI.h"
#include "4DPlugin.h"
#include "base64.h"

#include "pty_session.h"

#include <map>
#include <mutex>

#pragma mark - Session Management

static std::map<int, PtySession*> g_sessions;
static int g_nextId = 1;
static std::mutex g_mutex;

static PtySession* getSession(int sessionId) {
    auto it = g_sessions.find(sessionId);
    if (it != g_sessions.end()) {
        return it->second;
    }
    return nullptr;
}

#pragma mark - Lifecycle

static void OnStart() {
}

static void OnExit() {
    std::lock_guard<std::mutex> lock(g_mutex);
    for (auto& pair : g_sessions) {
        pair.second->close();
        delete pair.second;
    }
    g_sessions.clear();
}

#pragma mark - PluginMain

void PluginMain( PA_long32 selector, PA_PluginParameters params )
{
	switch( selector )
	{
    	case kInitPlugin :
		case kServerInitPlugin :
			OnStart();
			break;

		case kDeinitPlugin :
		case kServerDeinitPlugin :
			OnExit();
			break;

// --- pty

		case 1 :
			PTY_Create(params);
			break;
		case 2 :
			PTY_Write(params);
			break;
		case 3 :
			PTY_Read(params);
			break;
		case 4 :
			PTY_Set_window_size(params);
			break;
		case 5 :
			PTY_Close(params);
			break;
		case 6 :
			PTY_Get_status(params);
			break;
		case 7 :
			PTY_Send_signal(params);
			break;
		case 8 :
			PTY_List_sessions(params);
			break;

	}
}

#pragma mark - Commands

// PTY Create(shellPath : Text ; cols : Longint ; rows : Longint) : Longint
void PTY_Create(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    C_TEXT shellPathParam;
    shellPathParam.fromParamAtIndex(pParams, 1);

    C_LONGINT colsParam;
    colsParam.fromParamAtIndex(pParams, 2);

    C_LONGINT rowsParam;
    rowsParam.fromParamAtIndex(pParams, 3);

    C_TEXT cwdParam;
    cwdParam.fromParamAtIndex(pParams, 4);

    // Convert shell path to UTF-8
    CUTF8String shellPathUTF8;
    shellPathParam.copyUTF8String(&shellPathUTF8);
    std::string shellPath((const char*)shellPathUTF8.c_str(), shellPathUTF8.length());

    // Convert cwd to UTF-8
    CUTF8String cwdUTF8;
    cwdParam.copyUTF8String(&cwdUTF8);
    std::string cwd((const char*)cwdUTF8.c_str(), cwdUTF8.length());

    int16_t cols = (int16_t)colsParam.getIntValue();
    int16_t rows = (int16_t)rowsParam.getIntValue();

    if (cols <= 0) cols = 80;
    if (rows <= 0) rows = 24;

    C_LONGINT returnValue;

    std::lock_guard<std::mutex> lock(g_mutex);
    int sessionId = g_nextId++;
    PtySession* session = new PtySession(sessionId);

    if (session->start(shellPath.c_str(), cols, rows, cwd.empty() ? nullptr : cwd.c_str())) {
        g_sessions[sessionId] = session;
        returnValue.setIntValue(sessionId);
    } else {
        delete session;
        returnValue.setIntValue(0);
    }

    returnValue.setReturn((sLONG_PTR*)params->fResult);
}

// PTY Write(sessionId : Longint ; data : Text) : Longint
void PTY_Write(PA_PluginParameters params) {

    PA_long32 sessionId = PA_GetLongParameter(params, 1);
    PA_Unistring* ustr = PA_GetStringParameter(params, 2);

    C_LONGINT returnValue;

    std::lock_guard<std::mutex> lock(g_mutex);
    PtySession* session = getSession((int)sessionId);

    if (session != nullptr && ustr != nullptr) {
        C_TEXT dataParam;
        dataParam.setUTF16String(ustr);

        CUTF8String dataUTF8;
        dataParam.copyUTF8String(&dataUTF8);
        ssize_t written = session->write((const char*)dataUTF8.c_str(), dataUTF8.length());
        returnValue.setIntValue((int)written);
    } else {
        returnValue.setIntValue(-1);
    }

    returnValue.setReturn((sLONG_PTR*)params->fResult);
}

// PTY Read(sessionId : Longint ; maxBytes : Longint ; timeoutMs : Longint) : Text
void PTY_Read(PA_PluginParameters params) {

    C_LONGINT sessionIdParam;
    sessionIdParam.fromParamAtIndex((PackagePtr)params->fParameters, 1);

    C_LONGINT maxBytesParam;
    maxBytesParam.fromParamAtIndex((PackagePtr)params->fParameters, 2);

    C_LONGINT timeoutMsParam;
    timeoutMsParam.fromParamAtIndex((PackagePtr)params->fParameters, 3);

    int maxBytes = maxBytesParam.getIntValue();
    int timeoutMs = timeoutMsParam.getIntValue();

    if (maxBytes <= 0) maxBytes = 65536;

    C_TEXT returnValue;

    PtySession* session = nullptr;
    
    // Lock only to safely retrieve the session pointer.
    {
        std::lock_guard<std::mutex> lock(g_mutex);
        session = getSession(sessionIdParam.getIntValue());
    }

    if (session != nullptr) {
        // Perform the potentially blocking read WITHOUT holding the global plugin lock.
        std::string data = session->read((size_t)maxBytes, timeoutMs);
        if (!data.empty()) {
            // Encode the raw terminal output (which may contain partial UTF-8 sequences
            // or binary ANSI codes) to Base64 to prevent 4D's UTF-16 layer from corrupting it.
            std::string encoded = base64_encode(data);
            returnValue.setUTF8String((const uint8_t*)encoded.c_str(), (uint32_t)encoded.length());
        }
    }

    returnValue.setReturn((sLONG_PTR*)params->fResult);
}

// PTY Set window size(sessionId : Longint ; cols : Longint ; rows : Longint) : Longint
void PTY_Set_window_size(PA_PluginParameters params) {

    C_LONGINT sessionIdParam;
    sessionIdParam.fromParamAtIndex((PackagePtr)params->fParameters, 1);

    C_LONGINT colsParam;
    colsParam.fromParamAtIndex((PackagePtr)params->fParameters, 2);

    C_LONGINT rowsParam;
    rowsParam.fromParamAtIndex((PackagePtr)params->fParameters, 3);

    C_LONGINT returnValue;

    std::lock_guard<std::mutex> lock(g_mutex);
    PtySession* session = getSession(sessionIdParam.getIntValue());

    if (session != nullptr) {
        bool ok = session->resize((int16_t)colsParam.getIntValue(), (int16_t)rowsParam.getIntValue());
        returnValue.setIntValue(ok ? 1 : 0);
    } else {
        returnValue.setIntValue(0);
    }

    returnValue.setReturn((sLONG_PTR*)params->fResult);
}

// PTY Close(sessionId : Longint) : Longint
void PTY_Close(PA_PluginParameters params) {

    C_LONGINT sessionIdParam;
    sessionIdParam.fromParamAtIndex((PackagePtr)params->fParameters, 1);

    C_LONGINT returnValue;

    std::lock_guard<std::mutex> lock(g_mutex);
    PtySession* session = getSession(sessionIdParam.getIntValue());

    if (session != nullptr) {
        session->close();
        delete session;
        g_sessions.erase(sessionIdParam.getIntValue());
        returnValue.setIntValue(1);
    } else {
        returnValue.setIntValue(0);
    }

    returnValue.setReturn((sLONG_PTR*)params->fResult);
}

// PTY Get status(sessionId : Longint) : Object
void PTY_Get_status(PA_PluginParameters params) {

    C_LONGINT sessionIdParam;
    sessionIdParam.fromParamAtIndex((PackagePtr)params->fParameters, 1);

    std::lock_guard<std::mutex> lock(g_mutex);
    PtySession* session = getSession(sessionIdParam.getIntValue());

    if (session != nullptr) {
        session->checkRunning();

        PA_ObjectRef obj = PA_CreateObject();

        // pid
        PA_Unichar pidKey[] = {'p','i','d',0};
        PA_Unistring pidKeyStr = PA_CreateUnistring(pidKey);
        PA_Variable pidVar = PA_CreateVariable(eVK_Longint);
        PA_SetLongintVariable(&pidVar, (PA_long32)session->pid());
        PA_SetObjectProperty(obj, &pidKeyStr, pidVar);
        PA_DisposeUnistring(&pidKeyStr);
        PA_ClearVariable(&pidVar);

        // running
        PA_Unichar runKey[] = {'r','u','n','n','i','n','g',0};
        PA_Unistring runKeyStr = PA_CreateUnistring(runKey);
        PA_Variable runVar = PA_CreateVariable(eVK_Boolean);
        PA_SetBooleanVariable(&runVar, session->isRunning() ? 1 : 0);
        PA_SetObjectProperty(obj, &runKeyStr, runVar);
        PA_DisposeUnistring(&runKeyStr);
        PA_ClearVariable(&runVar);

        // exitCode
        PA_Unichar exitKey[] = {'e','x','i','t','C','o','d','e',0};
        PA_Unistring exitKeyStr = PA_CreateUnistring(exitKey);
        PA_Variable exitVar = PA_CreateVariable(eVK_Longint);
        PA_SetLongintVariable(&exitVar, (PA_long32)session->exitCode());
        PA_SetObjectProperty(obj, &exitKeyStr, exitVar);
        PA_DisposeUnistring(&exitKeyStr);
        PA_ClearVariable(&exitVar);

        PA_ReturnObject(params, obj);
    }
}

// PTY Send signal(sessionId : Longint ; signal : Longint) : Longint
void PTY_Send_signal(PA_PluginParameters params) {

    C_LONGINT sessionIdParam;
    sessionIdParam.fromParamAtIndex((PackagePtr)params->fParameters, 1);

    C_LONGINT signalParam;
    signalParam.fromParamAtIndex((PackagePtr)params->fParameters, 2);

    C_LONGINT returnValue;

    std::lock_guard<std::mutex> lock(g_mutex);
    PtySession* session = getSession(sessionIdParam.getIntValue());

    if (session != nullptr) {
        bool ok = session->sendSignal(signalParam.getIntValue());
        returnValue.setIntValue(ok ? 1 : 0);
    } else {
        returnValue.setIntValue(0);
    }

    returnValue.setReturn((sLONG_PTR*)params->fResult);
}

// PTY List sessions : Collection
void PTY_List_sessions(PA_PluginParameters params) {

    std::lock_guard<std::mutex> lock(g_mutex);

    PA_CollectionRef col = PA_CreateCollection();
    PA_long32 index = 0;

    for (auto& pair : g_sessions) {
        PA_Variable elem = PA_CreateVariable(eVK_Longint);
        PA_SetLongintVariable(&elem, (PA_long32)pair.first);
        PA_SetCollectionElement(col, index++, elem);
        PA_ClearVariable(&elem);
    }

    PA_ReturnCollection(params, col);
}
